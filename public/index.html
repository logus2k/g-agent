<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>g-agent</title>

	<link rel="icon" href="/favicon-bold.ico" sizes="any">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-bold-32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-bold-16.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/favicon-bold-180.png">
	<link rel="icon" type="image/png" sizes="512x512" href="/favicon-terminal-green-bold-512.png">

	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", sans-serif;
			background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
			color: #e0e0e0;
			height: 100vh;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 20px;
		}

		.container {
			width: 100%;
			max-width: 700px;
			height: 100%;
			max-height: 800px;
			display: flex;
			flex-direction: column;
			background: rgba(20, 20, 35, 0.95);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 12px;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
			overflow: hidden;
		}

		.header {
			padding: 16px 20px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.1);
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.header h1 {
			font-size: 18px;
			font-weight: 600;
		}

		.header-controls {
			display: flex;
			gap: 8px;
			align-items: center;
		}

		.status-indicator {
			display: flex;
			align-items: center;
			gap: 6px;
			font-size: 12px;
		}

		.status-dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: #4a9eff;
			animation: pulse 2s infinite;
		}

		.status-dot.offline {
			background: #ff6b6b;
			animation: none;
		}

		@keyframes pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.5; }
		}

		.chat-messages {
			flex: 1;
			overflow-y: auto;
			padding: 16px;
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		.message {
			display: flex;
			gap: 8px;
			animation: fadeIn 0.3s ease;
		}

		@keyframes fadeIn {
			from { opacity: 0; transform: translateY(8px); }
			to { opacity: 1; transform: translateY(0); }
		}

		.message.user {
			justify-content: flex-end;
		}

		.message-bubble {
			max-width: 85%;
			padding: 10px 14px;
			border-radius: 8px;
			word-wrap: break-word;
			line-height: 1.4;
			font-size: 14px;
		}

		.message.assistant .message-bubble {
			background: rgba(74, 158, 255, 0.15);
			border-left: 3px solid #4a9eff;
		}

		.message.user .message-bubble {
			background: rgba(74, 158, 255, 0.25);
			color: #fff;
		}

		.message.error .message-bubble {
			background: rgba(255, 107, 107, 0.15);
			border-left: 3px solid #ff6b6b;
			color: #ffb0b0;
		}

		/* Markdown styling in messages */
		.message-bubble h1,
		.message-bubble h2,
		.message-bubble h3 {
			margin-top: 10px;
			margin-bottom: 6px;
			font-size: 1em;
		}

		.message-bubble code {
			background: rgba(0, 0, 0, 0.3);
			padding: 2px 6px;
			border-radius: 3px;
			font-size: 0.9em;
			font-family: "Courier New", monospace;
		}

		.message-bubble pre {
			background: rgba(0, 0, 0, 0.3);
			padding: 8px;
			border-radius: 4px;
			overflow-x: auto;
			margin: 8px 0;
		}

		.message-bubble pre code {
			padding: 0;
			background: none;
		}

		.message-bubble ul,
		.message-bubble ol {
			margin-left: 20px;
			margin-top: 6px;
			margin-bottom: 6px;
		}

		.message-bubble a {
			color: #4a9eff;
			text-decoration: none;
			border-bottom: 1px dotted #4a9eff;
		}

		.message-bubble a:hover {
			text-decoration: underline;
		}

		.input-area {
			padding: 12px;
			border-top: 1px solid rgba(255, 255, 255, 0.1);
			display: flex;
			gap: 8px;
			background: rgba(10, 10, 20, 0.5);
		}

		.input-row {
			display: flex;
			gap: 8px;
			align-items: flex-end;
			flex: 1;
		}

		.chat-input {
			flex: 1;
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 6px;
			padding: 10px 12px;
			color: #e0e0e0;
			font-family: inherit;
			font-size: 14px;
			resize: none;
			max-height: 100px;
		}

		.chat-input:focus {
			outline: none;
			border-color: rgba(74, 158, 255, 0.3);
			background: rgba(255, 255, 255, 0.08);
		}

		.chat-input::placeholder {
			color: rgba(224, 224, 224, 0.4);
		}

		.btn {
			padding: 8px 12px;
			border: none;
			border-radius: 6px;
			cursor: pointer;
			font-size: 12px;
			font-weight: 500;
			transition: all 0.2s ease;
			display: inline-flex;
			align-items: center;
			gap: 4px;
		}

		.btn-primary {
			background: rgba(74, 158, 255, 0.8);
			color: #fff;
			height: 39px;
		}

		.btn-primary:hover:not(:disabled) {
			background: rgba(74, 158, 255, 1);
			transform: translateY(-1px);
		}

		.btn-secondary {
			background: rgba(255, 255, 255, 0.05);
			color: #e0e0e0;
			border: 1px solid rgba(255, 255, 255, 0.1);
		}

		.btn-secondary:hover:not(:disabled) {
			background: rgba(255, 255, 255, 0.1);
		}

		.btn:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		.controls-row {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
		}

		.settings-panel {
			display: none;
			position: absolute;
			top: 60px;
			right: 20px;
			background: rgba(20, 20, 35, 0.98);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 8px;
			padding: 16px;
			width: 300px;
			z-index: 1000;
			max-height: 400px;
			overflow-y: auto;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
		}

		.settings-panel.open {
			display: block;
		}

		.settings-group {
			margin-bottom: 16px;
		}

		.settings-group:last-child {
			margin-bottom: 0;
		}

		.settings-group label {
			display: block;
			font-size: 12px;
			color: rgba(224, 224, 224, 0.7);
			margin-bottom: 6px;
			font-weight: 500;
		}

		.settings-group input[type="text"],
		.settings-group select {
			width: 100%;
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 4px;
			padding: 8px;
			color: #e0e0e0;
			font-size: 12px;
		}

		.settings-group input[type="text"]:focus,
		.settings-group select:focus {
			outline: none;
			border-color: rgba(74, 158, 255, 0.3);
			background: rgba(255, 255, 255, 0.08);
		}

		.toggle-switch {
			display: inline-flex;
			width: 40px;
			height: 20px;
			background: rgba(255, 255, 255, 0.1);
			border-radius: 10px;
			cursor: pointer;
			padding: 2px;
			align-items: center;
			transition: background 0.2s ease;
		}

		.toggle-switch.on {
			background: rgba(74, 158, 255, 0.5);
		}

		.toggle-switch::after {
			content: '';
			width: 16px;
			height: 16px;
			background: rgba(255, 255, 255, 0.8);
			border-radius: 50%;
			transition: transform 0.2s ease;
		}

		.toggle-switch.on::after {
			transform: translateX(20px);
		}

		.info-text {
			font-size: 11px;
			color: rgba(224, 224, 224, 0.5);
			margin-top: 4px;
		}

		@media (max-width: 600px) {
			.message-bubble {
				max-width: 95%;
			}

			.container {
				max-width: 100%;
				max-height: 100%;
				border-radius: 0;
			}

			.settings-panel {
				width: calc(100vw - 40px);
				right: 20px;
			}
		}
	</style>
</head>

<body>

	<div class="container">

		<!-- Header -->
		<div class="header">
			<h1>g-agent</h1>
			<div class="header-controls">
				<div class="status-indicator">
					<span id="status-text">Connecting...</span>
					<div class="status-dot offline" id="status-dot"></div>
				</div>
				<button class="btn btn-secondary" id="settings-btn" title="Settings">‚öôÔ∏è</button>
			</div>
		</div>

		<!-- Settings Panel -->
		<div class="settings-panel" id="settings-panel">
			<div class="settings-group">
				<label>LLM Server URL</label>
				<input type="text" id="llm-url" placeholder="https://example.com/llm" />
				<div class="info-text">Agent server URL (default: current origin)</div>
			</div>

			<div class="settings-group">
				<label>Agent Name</label>
				<input type="text" id="agent-name" placeholder="ml" value="ml" />
				<div class="info-text">Agent identifier on the server</div>
			</div>

			<div class="settings-group">
				<label>STT Server URL</label>
				<input type="text" id="stt-url" placeholder="https://example.com/stt" />
				<div class="info-text">Speech-to-Text service (optional)</div>
			</div>

			<div class="settings-group">
				<label>TTS Enabled</label>
				<div class="toggle-switch" id="tts-toggle"></div>
				<div class="info-text">Enable Text-to-Speech responses</div>
			</div>

			<div class="settings-group">
				<button class="btn btn-primary" id="save-settings-btn" style="width: 100%;">Save Settings</button>
			</div>
		</div>

		<!-- Chat Messages -->
		<div class="chat-messages" id="chat-messages"></div>

		<!-- Input Area -->
		<div class="input-area">
			<div class="input-row">
				<textarea
					id="chat-input"
					class="chat-input"
					placeholder="Type your message... (Enter to send, Shift+Enter for new line)"
					rows="1"></textarea>
				<button class="btn btn-primary" id="send-button" title="Send message">‚Üë</button>
			</div>
			<div class="controls-row">
				<button class="btn btn-secondary" id="mic-button" title="Record voice">üé§</button>
				<button class="btn btn-secondary" id="clear-button" title="Clear chat">üóëÔ∏è</button>
			</div>
		</div>

	</div>

	<!-- Libraries -->
	<script src="./library/socket.io.min.js"></script>
	<script src="./library/marked.min.js"></script>
	<script src="./library/purify.min.js"></script>
	<script src="./library/highlight.min.js"></script>

	<!-- Agent modules -->
	<script type="module">
		import { AgentClient } from "./script/agentClient.js";
		import { AudioResampler } from "./script/audioResampler.js";
		import { initLLM } from "./script/llm-bridge.js";

		class GenericAgent {
			constructor() {
				this.llmUrl = localStorage.getItem("llm_url") || "https://logus2k.com/llm";
				this.agentName = localStorage.getItem("agent_name") || "ml";
				this.sttUrl = localStorage.getItem("stt_url") || "https://logus2k.com/stt";
				this.ttsEnabled = localStorage.getItem("tts_enabled") === null ? true : localStorage.getItem("tts_enabled") === "true";

				this.client = null;
				this.send = null;
				this.cancel = null;

				// Use global clientId like Gaia - persists across socket reconnections
				this.clientId = window.__clientId || (window.__clientId = (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2)));

				// STT state
				this.sttSocket = null;
				this.audioCtx = null;
				this.mediaStream = null;
				this.sourceNode = null;
				this.workletNode = null;
				this.resampler = null;
				this.isRecording = false;

				// TTS state
				this.ttsSocket = null;
				this.ttsAudioCtx = null;
				this.ttsPlayQueue = Promise.resolve();

				// UI state
				this.activeAssistantBubble = null;

				this._cacheDom();
				this._bindUI();
				this._loadSettings();
			}

			_cacheDom() {
				this.chatMessages = document.getElementById("chat-messages");
				this.chatInput = document.getElementById("chat-input");
				this.sendButton = document.getElementById("send-button");
				this.micButton = document.getElementById("mic-button");
				this.clearButton = document.getElementById("clear-button");
				this.settingsBtn = document.getElementById("settings-btn");
				this.settingsPanel = document.getElementById("settings-panel");
				this.statusText = document.getElementById("status-text");
				this.statusDot = document.getElementById("status-dot");
				this.llmUrlInput = document.getElementById("llm-url");
				this.agentNameInput = document.getElementById("agent-name");
				this.sttUrlInput = document.getElementById("stt-url");
				this.ttsToggle = document.getElementById("tts-toggle");
				this.saveSettingsBtn = document.getElementById("save-settings-btn");
			}

			_bindUI() {
				this.sendButton.addEventListener("click", () => this.doSend());
				this.chatInput.addEventListener("keydown", (e) => {
					if (e.key === "Enter" && !e.shiftKey) {
						e.preventDefault();
						this.doSend();
					}
				});

				this.micButton.addEventListener("click", () => this.toggleRecording());
				this.clearButton.addEventListener("click", () => this.doClear());

				this.settingsBtn.addEventListener("click", () => {
					this.settingsPanel.classList.toggle("open");
				});

				document.addEventListener("click", (e) => {
					if (!e.target.closest("#settings-btn") && !e.target.closest(".settings-panel")) {
						this.settingsPanel.classList.remove("open");
					}
				});

				this.ttsToggle.addEventListener("click", async () => {
					const isCurrentlyEnabled = this.ttsToggle.classList.contains("on");
					try {
						if (isCurrentlyEnabled) {
							await this._disableTTS();
							this.ttsToggle.classList.remove("on");
						} else {
							await this._enableTTS();
							this.ttsToggle.classList.add("on");
						}
					} catch (e) {
						this._addMessage("error", `TTS error: ${e.message}`);
						console.error("[TTS]", e);
					}
				});

				this.saveSettingsBtn.addEventListener("click", () => this._saveSettings());
			}

			_loadSettings() {
				this.llmUrlInput.value = this.llmUrl;
				this.agentNameInput.value = this.agentName;
				this.sttUrlInput.value = this.sttUrl;
				this.ttsToggle.classList.toggle("on", this.ttsEnabled);
			}

			_saveSettings() {
				this.llmUrl = this.llmUrlInput.value || location.origin;
				this.agentName = this.agentNameInput.value || "ml";
				this.sttUrl = this.sttUrlInput.value || "";
				this.ttsEnabled = this.ttsToggle.classList.contains("on");

				localStorage.setItem("llm_url", this.llmUrl);
				localStorage.setItem("agent_name", this.agentName);
				localStorage.setItem("stt_url", this.sttUrl);
				localStorage.setItem("tts_enabled", this.ttsEnabled);

				this.settingsPanel.classList.remove("open");
				this._addMessage("info", "Settings saved. Please restart the chat.");
			}

			async init() {
				try {
					const { client, send, cancel, getThreadId, setThreadId } = await initLLM({
						url: this.llmUrl,
						agent: this.agentName,
						clientId: this.clientId,
						onStarted: () => {
							this.activeAssistantBubble = this._addMessage("assistant", "");
						},
						onText: (text) => {
							if (!this.activeAssistantBubble) {
								this.activeAssistantBubble = this._addMessage("assistant", "");
							}
							const html = window.marked?.parse ? window.marked.parse(text) : text;
							this.activeAssistantBubble.innerHTML = window.DOMPurify
								? window.DOMPurify.sanitize(html)
								: html;
							this.chatMessages.scrollTop = this.chatMessages.scrollHeight;

							if (window.hljs) {
								this.activeAssistantBubble.querySelectorAll("pre code").forEach((el) => {
									window.hljs.highlightElement(el);
								});
							}
						},
						onDone: () => {
							this.activeAssistantBubble = null;
						},
						onError: (e) => {
							this.activeAssistantBubble = null;
							this._addMessage("error", `Error: ${e.message}`);
						},
						onReconnect: () => {
							this._setStatus(true);
						}
					});

					this.client = client;
					this.send = send;
					this.cancel = cancel;
					this.getThreadId = getThreadId;
					this.setThreadId = setThreadId;

					// Add TTSAudio handler to the agent client
					this.client.onTTSAudio(async (payload) => {
						console.log("[TTS] Received audio from agent server, size:", payload?.data?.byteLength || "unknown");
						const buf = payload?.data;
						if (!buf) return;

						const actx = this._ensureTtsAudioContext();
						try {
							const audioBuf = await actx.decodeAudioData(buf.slice ? buf.slice(0) : buf);
							this.ttsPlayQueue = this.ttsPlayQueue.then(() => {
								const src = actx.createBufferSource();
								src.buffer = audioBuf;
								src.connect(actx.destination);
								src.start();
								return new Promise(res => { src.onended = res; });
							});
							console.log("[TTS] Audio queued for playback from agent server");
						} catch (e) {
							console.warn("[TTS] Decode error from agent server:", e);
						}
					});					

					this._setStatus(true);
					this._addMessage("assistant", "Hello! I'm ready to chat. Type a message or use the microphone button to speak.");

					// Initialize STT socket and subscription once (reused for all recordings)
					try {
						await this._ensureSttSubscribed();
						await this._ensureSttSocket();
					} catch (e) {
						console.warn("[STT] Failed to initialize on init:", e?.message);
					}

					// Enable TTS if toggle is on
					if (this.ttsToggle.classList.contains("on")) {
						try {
							await this._enableTTS();
						} catch (e) {
							console.warn("[TTS] Failed to enable on init:", e?.message);
						}
					}

				} catch (e) {
					this._setStatus(false);
					this._addMessage("error", `Failed to initialize: ${e.message}`);
					console.error(e);
				}
			}

			_setStatus(connected) {
				if (connected) {
					this.statusText.textContent = "Connected";
					this.statusDot.classList.remove("offline");
				} else {
					this.statusText.textContent = "Offline";
					this.statusDot.classList.add("offline");
				}
			}

			_addMessage(type, content) {
				const wrapper = document.createElement("div");
				wrapper.className = `message ${type}`;

				const bubble = document.createElement("div");
				bubble.className = "message-bubble";
				bubble.innerHTML = content;

				wrapper.appendChild(bubble);
				this.chatMessages.appendChild(wrapper);
				this.chatMessages.scrollTop = this.chatMessages.scrollHeight;

				return bubble;
			}

			async doSend() {
				const text = this.chatInput.value.trim();
				if (!text) return;

				this.chatInput.value = "";
				this.chatInput.style.height = "auto";
				this._addMessage("user", text);

				try {
					await this.send(text);
				} catch (e) {
					this._addMessage("error", `Send failed: ${e.message}`);
				}
			}

			doClear() {
				if (confirm("Clear all messages?")) {
					this.chatMessages.innerHTML = "";
					this.activeAssistantBubble = null;
				}
			}

			async toggleRecording() {
				if (this.isRecording) {
					await this.stopRecording();
				} else {
					await this.startRecording();
				}
			}

			async startRecording() {
				if (this.isRecording) return;
				this.isRecording = true;

				try {
					// STT socket and subscription already initialized in init()

					// Get microphone
					this.mediaStream = await navigator.mediaDevices.getUserMedia({
						audio: {
							channelCount: 1,
							echoCancellation: true,
							noiseSuppression: true,
							autoGainControl: false
						}
					});

					// Create audio context
					this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
						sampleRate: 48000,
						latencyHint: "interactive"
					});
					await this.audioCtx.resume();

					// Setup audio worklet
					await this.audioCtx.audioWorklet.addModule("./script/recorder.worklet.js");
					this.sourceNode = this.audioCtx.createMediaStreamSource(this.mediaStream);
					this.workletNode = new AudioWorkletNode(this.audioCtx, "recorder-worklet", {
						numberOfInputs: 1,
						numberOfOutputs: 0,
						channelCount: 1,
						channelCountMode: "explicit"
					});
					this.sourceNode.connect(this.workletNode);

					// Setup resampler 48k -> 16k
					this.resampler = new AudioResampler(this.audioCtx.sampleRate, 16000);

					// Packetize ~100ms and send to STT
					let pending = [];
					let pendingLength = 0;
					const PACKET_MS = 100;
					const sampleRate = this.audioCtx.sampleRate;
					let packetsProcessed = 0;

					this.workletNode.port.onmessage = (e) => {
						if (!this.isRecording) return;
						const chunk = e.data;
						if (!chunk?.length) return;

						pending.push(chunk);
						pendingLength += chunk.length;

						const samplesPerPacket = Math.round(sampleRate * (PACKET_MS / 1000));
						if (pendingLength >= samplesPerPacket) {
							const merged = new Float32Array(pendingLength);
							let offset = 0;
							for (const part of pending) {
								merged.set(part, offset);
								offset += part.length;
							}
							pending = [];
							pendingLength = 0;

							if (!this.isRecording || !this.resampler || !this.sttSocket?.connected) return;
							try {
								const pcm16 = this.resampler.pushFloat32(merged);
								if (pcm16?.length > 0) {
									this.sttSocket.emit("audio_data", {
										clientId: this.clientId,
										audioData: pcm16.buffer
									});
									packetsProcessed++;
									if (packetsProcessed === 1) {
										console.log("[STT] First audio packet sent - recording active");
									}
								}
							} catch (err) {
								console.error("[STT] Error processing audio:", err);
							}
						}
					};

					this.micButton.style.opacity = "0.5";
					this.micButton.style.background = "rgba(255, 107, 107, 0.3)";
					this._addMessage("info", "üé§ Recording...");
					console.log("[STT] Recording started successfully");

				} catch (e) {
					this.isRecording = false;
					this.micButton.style.opacity = "1";
					this.micButton.style.background = "";
					this._addMessage("error", `Recording error: ${e.message}`);
					console.error("[Recording]", e);
				}
			}

			async stopRecording() {
				try {
					if (this.sourceNode) {
						this.sourceNode.disconnect();
						this.sourceNode = null;
					}
					if (this.workletNode) {
						this.workletNode.disconnect();
						this.workletNode = null;
					}
					if (this.mediaStream) {
						this.mediaStream.getTracks().forEach((t) => t.stop());
						this.mediaStream = null;
					}
					if (this.resampler) {
						this.resampler.reset();
					}

					this.isRecording = false;
					this.micButton.style.opacity = "1";
					this.micButton.style.background = "";
					this._addMessage("info", "üé§ Recording stopped.");  // Add this line

				} catch (e) {
					console.error("Stop recording error:", e);
				}
			}

			async _ensureSttSubscribed() {
				if (!this.client?.sttSubscribe) return;
				try {
					await this.client.sttSubscribe({
						sttUrl: this.sttUrl,
						clientId: this.clientId,
						agent: this.agentName,
						threadId: this.getThreadId?.()
					});
					console.log("[STT] Subscribed via agent server, threadId:", this.getThreadId?.());
				} catch (e) {
					console.warn("[STT] Subscribe error:", e?.message);
				}
			}

			async _ensureSttSocket() {
				if (this.sttSocket?.connected) return;

				if (!this.sttUrl) {
					throw new Error("STT URL not configured");
				}

				if (!window.io) {
					throw new Error("socket.io client not available");
				}

				const sttOrigin = new URL(this.sttUrl, window.location.origin).origin;
				this.sttSocket = window.io(sttOrigin, {
					path: "/stt/socket.io",
					transports: ["websocket", "polling"],
					forceNew: true
				});

				await new Promise((resolve, reject) => {
					this.sttSocket.once("connect", resolve);
					this.sttSocket.once("connect_error", reject);
				});

				console.log("[STT] Socket connected");
			}

			async _enableTTS() {
				try {
					// Tell agent_server to stream text to TTS
					if (this.client?.ttsSubscribe) {
						console.log("[TTS] Subscribing via agent server, clientId:", this.clientId);
						await this.client.ttsSubscribe({ clientId: this.clientId });
						console.log("[TTS] Subscribed via agent server");
					}

					// Connect directly to TTS server
					await this._ensureTtsSocket();
					console.log("[TTS] enabled");
				} catch (e) {
					console.error("[TTS] Enable error:", e);
					throw e;
				}
			}

			async _disableTTS() {
				try {
					if (this.client?.ttsUnsubscribe) {
						await this.client.ttsUnsubscribe({ clientId: this.clientId });
					}
				} catch (e) {
					console.warn("[TTS] Unsubscribe error:", e?.message);
				}

				try {
					this.ttsSocket?.disconnect();
				} catch {}
				this.ttsSocket = null;

				this._closeTtsAudioContext();
				console.log("[TTS] disabled");
			}

			async _ensureTtsSocket() {
				if (this.ttsSocket?.connected) {
					console.log("[TTS-DEBUG] Socket already connected, skipping setup");
					return;
				}

				console.log("[TTS-DEBUG] Setting up new TTS socket");

				if (!this.llmUrl) {
					throw new Error("LLM URL not configured");
				}

				if (!window.io) {
					throw new Error("socket.io client not available");
				}

				const llmOrigin = new URL(this.llmUrl, window.location.origin).origin;
				const socket = window.io(llmOrigin, {
					path: "/tts/socket.io",
					transports: ["websocket", "polling"],
					forceNew: true,
					query: { type: "browser", format: "binary", main_client_id: this.clientId }
				});

				console.log("[TTS] Connecting to", llmOrigin, "via", "/tts/socket.io");

				await new Promise((resolve, reject) => {
					socket.once("connect", () => {
						console.log("[TTS] Socket connected");
						resolve();
					});
					socket.once("connect_error", (err) => {
						console.error("[TTS] Connection error:", err);
						reject(err);
					});
				});

				// Register as audio client
				await new Promise((resolve, reject) => {
					socket.emit("register_audio_client",
						{ main_client_id: this.clientId, connection_type: "browser", mode: "tts" },
						(ack) => {
							console.log("[TTS] Registered audio client, ack:", ack);
							resolve();
						}
					);
				});

				// Handle incoming audio chunks
				socket.on("tts_audio_chunk", async (evt) => {
					console.log("[TTS] Received audio chunk, size:", evt?.audio_buffer?.byteLength || evt?.audio_buffer?.length || "unknown");
					const buf = evt?.audio_buffer;
					if (!buf) return;

					const actx = this._ensureTtsAudioContext();
					try {
						const audioBuf = await actx.decodeAudioData(buf.slice ? buf.slice(0) : buf);
						this.ttsPlayQueue = this.ttsPlayQueue.then(() => {
							const src = actx.createBufferSource();
							src.buffer = audioBuf;
							src.connect(actx.destination);
							src.start();
							return new Promise(res => { src.onended = res; });
						});
						console.log("[TTS] Audio queued for playback");
					} catch (e) {
						console.warn("[TTS] Decode error:", e);
					}
				});

				socket.on("tts_stop_immediate", () => {
					console.log("[TTS] Stop received - destroying audio context and clearing queue");
					// Close/destroy the audio context - this stops ALL audio immediately
					this._closeTtsAudioContext();
					// Clear the queue
					this.ttsPlayQueue = Promise.resolve();
					console.log("[TTS] Audio context destroyed and queue cleared");
				});

				this.ttsSocket = socket;
				console.log("[TTS-DEBUG] TTS socket setup complete");
			}

			
			_ensureTtsAudioContext() {
				if (!this.ttsAudioCtx) {
					this.ttsAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
				}
				return this.ttsAudioCtx;
			}

			_closeTtsAudioContext() {
				if (this.ttsAudioCtx) {
					try { this.ttsAudioCtx.close(); } catch {}
					this.ttsAudioCtx = null;
				}
			}
		}

		// Initialize on DOM ready
		document.addEventListener("DOMContentLoaded", async () => {
			const agent = new GenericAgent();
			await agent.init();

			// Expose for debugging
			window.agent = agent;
		});
	</script>

</body>

</html>
